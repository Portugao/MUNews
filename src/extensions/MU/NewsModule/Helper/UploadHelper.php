<?php

/**
 * News.
 *
 * @copyright Michael Ueberschaer (MU)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Michael Ueberschaer <info@homepages-mit-zikula.de>.
 * @see https://homepages-mit-zikula.de
 * @see https://ziku.la
 * @version Generated by ModuleStudio (https://modulestudio.de).
 */

declare(strict_types=1);

namespace MU\NewsModule\Helper;

use Imagine\Filter\Basic\Autorotate;
use Imagine\Gd\Imagine;
use Imagine\Image\Box;
use Imagine\Image\ImageInterface;
use MU\NewsModule\Helper\Base\AbstractUploadHelper;
use Symfony\Component\HttpFoundation\File\File;
use Symfony\Component\HttpFoundation\File\UploadedFile;

/**
 * Helper implementation class for upload handling.
 */
class UploadHelper extends AbstractUploadHelper
{
    public function performFileUpload(string $objectType, UploadedFile $file, string $fieldName): array
    {
        if ('message' !== $objectType) {
            return parent::performFileUpload($objectType, $file, $fieldName);
        }

        $result = [
            'fileName' => '',
            'metaData' => []
        ];
    
        // check whether uploads are allowed for the given object type
        if (!in_array($objectType, $this->allowedObjectTypes, true)) {
            return $result;
        }
    
        // perform validation
        if (!$this->validateFileUpload($objectType, $file, $fieldName)) {
            return $result;
        }
    
        // build the file name
        $fileName = $file->getClientOriginalName();
        $fileNameParts = explode('.', $fileName);
        $extension = $this->determineFileExtension($file);
        $fileNameParts[count($fileNameParts) - 1] = $extension;
        $fileName = implode('.', $fileNameParts);
    
        $request = $this->requestStack->getCurrentRequest();
        $session = $request->hasSession() ? $request->getSession() : null;
        $flashBag = null !== $session ? $session->getFlashBag() : null;
    
        // retrieve the final file name
        try {
            $basePath = $this->kernel->getProjectDir() . '/' . $this->getFileBaseFolder($objectType, $fieldName);
        } catch (\Exception $exception) {
            if (null !== $flashBag) {
                $flashBag->add('error', $exception->getMessage());
            }
            $logArgs = [
                'app' => 'MUNewsModule',
                'user' => $this->currentUserApi->get('uname'),
                'entity' => $objectType,
                'field' => $fieldName
            ];
            $this->logger->error(
                '{app}: User {user} could not detect upload destination path for entity {entity} and field {field}. '
                    . ' ' . $exception->getMessage(),
                $logArgs
            );

            return $result;
        }
        $fileName = $this->determineFileName($objectType, $fieldName, $basePath, $fileName, $extension);
    
        $destinationFilePath = $basePath . $fileName;
        $targetFile = $file->move($basePath, $fileName);

        // validate image file
        $isImage = in_array($extension, $this->imageFileTypes, true);
        if ($isImage) {
            $imgInfo = getimagesize($destinationFilePath);
            if (!is_array($imgInfo) || !$imgInfo[0] || !$imgInfo[1]) {
                if (null !== $flashBag) {
                    $flashBag->add('error', $this->trans('Error! This file type seems not to be a valid image.'));
                }
                $this->logger->error(
                    '{app}: User {user} tried to upload a file which is seems not to be a valid image.',
                    ['app' => 'MUNewsModule', 'user' => $this->currentUserApi->get('uname')]
                );
        
                return false;
            }
        }
        
        // validate size
        // get file size of uploaded image
        $fileSize = filesize($destinationFilePath);

        // get setting - mod var
        $maxSize = $this->moduleVars['maxSize'];
        
        // if not empty, validate
        if ('' !== $maxSize) {
            if (false !== strpos($maxSize, 'k')) {
                $sizeType = 'kilo';
            } elseif (false !== strpos($maxSize, 'M')) {
                $sizeType = 'mega';
            } elseif (false === strpos($maxSize, 'k') && false === strpos($maxSize, 'M')) {
                $sizeType = 'byte';
            }

            if ('byte' === $sizeType && $fileSize > $maxSize) {
                if (null !== $flashBag) {
                    $flashBag->add('error', $this->trans('Error! This file is too big.'));
                    $flashBag->add(
                        'status',
                        $this->trans(
                            'Try another image or make the file size smaller than %amount% bytes.',
                            ['%amount%' => $setMaxSize]
                        )
                    );
                }

                return false;
            }

            if ('kilo' === $sizeType) {
                $maxSize = str_replace('k', '', $maxSize);
                $setMaxSize = $maxSize;
                $maxSize *= 1024;
                if ($fileSize > $maxSize) {
                    if (null !== $flashBag) {
                        $flashBag->add('error', $this->trans('Error! This file is too big.'));
                        $flashBag->add(
                            'status',
                            $this->trans(
                                'Try another image or make the file size smaller than %amount% kilobytes.',
                                ['%amount%' => $setMaxSize]
                            )
                        );
                    }

                    return false;
                }
            }

            if ('mega' === $sizeType) {
                $maxSize = str_replace('M', '', $maxSize);
                $setMaxSize = $maxSize;
                $maxSize = $maxSize * 1024 * 1024;
                if ($fileSize > $maxSize) {
                    if (null !== $flashBag) {
                        $flashBag->add('error', $this->trans('Error! This file is too big.'));
                        $flashBag->add(
                            'status',
                            $this->trans(
                                'Try another image or make the file size smaller than %amount% megabytes.',
                                ['%amount%' => $setMaxSize]
                            )
                        );
                    }

                    return false;
                }
            }
        }

        // collect data to return
        $result['fileName'] = $fileName;
        $result['metaData'] = $this->readMetaDataForFile($fileName, $destinationFilePath);

        $isImage = in_array($extension, $this->imageFileTypes, true);
        if ($isImage && 'gif' !== $extension) {
            // fix wrong orientation and shrink too large image if needed
            @ini_set('memory_limit', '1G');
            $imagine = new Imagine();
            $image = $imagine->open($destinationFilePath);
            $autorotateFilter = new Autorotate();
            $image = $autorotateFilter->apply($image);
            $image->save($destinationFilePath);

            // check if shrinking functionality is enabled
            $fieldSuffix = ucfirst($objectType) . ucfirst($fieldName);
            if (
                isset($this->moduleVars['enableShrinkingFor' . $fieldSuffix])
                && true === (bool)$this->moduleVars['enableShrinkingFor' . $fieldSuffix]
            ) {
                // check for maximum size
                $maxWidth = isset($this->moduleVars['shrinkWidth' . $fieldSuffix])
                    ? $this->moduleVars['shrinkWidth' . $fieldSuffix]
                    : 800
                ;
                $maxHeight = isset($this->moduleVars['shrinkHeight' . $fieldSuffix])
                    ? $this->moduleVars['shrinkHeight' . $fieldSuffix]
                    : 600
                ;
                $thumbMode = isset($this->moduleVars['thumbnailMode' . $fieldSuffix])
                    ? $this->moduleVars['thumbnailMode' . $fieldSuffix]
                    : ImageInterface::THUMBNAIL_INSET
                ;
    
                $imgInfo = getimagesize($destinationFilePath);
                if ($imgInfo[0] > $maxWidth || $imgInfo[1] > $maxHeight) {
                    // resize to allowed maximum size
                    $imagine = new Imagine();
                    $image = $imagine->open($destinationFilePath);
                    $thumb = $image->thumbnail(new Box($maxWidth, $maxHeight), $thumbMode);
                    $thumb->save($destinationFilePath);
                }
            }

            // update meta data excluding EXIF
            $newMetaData = $this->readMetaDataForFile($fileName, $destinationFilePath, false);
            $result['metaData'] = array_merge($result['metaData'], $newMetaData);
        }

        return $result;
    }
}
