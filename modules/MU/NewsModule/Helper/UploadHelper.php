<?php
/**
 * News.
 *
 * @copyright Michael Ueberschaer (MU)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Michael Ueberschaer <info@homepages-mit-zikula.de>.
 * @link https://homepages-mit-zikula.de
 * @link https://ziku.la
 * @version Generated by ModuleStudio (https://modulestudio.de).
 */

namespace MU\NewsModule\Helper;

use MU\NewsModule\Helper\Base\AbstractUploadHelper;

use Imagine\Filter\Basic\Autorotate;
use Imagine\Gd\Imagine;
use Imagine\Image\Box;
use Imagine\Image\ImageInterface;
use Symfony\Component\HttpFoundation\File\File;
use Symfony\Component\HttpFoundation\File\UploadedFile;

/**
 * Helper implementation class for upload handling.
 */
class UploadHelper extends AbstractUploadHelper
{
    /**
     * Process a file upload.
     *
     * @param string       $objectType Currently treated entity type
     * @param UploadedFile $file       The uploaded file
     * @param string       $fieldName  Name of upload field
     *
     * @return array Resulting file name and collected meta data
     */
    public function performFileUpload($objectType, $file, $fieldName)
    {
        if ('message' != $objectType) {
            return parent::performFileUpload($objectType, $file, $fieldName);
        }

        $result = [
            'fileName' => '',
            'metaData' => []
        ];
    
        // check whether uploads are allowed for the given object type
        if (!in_array($objectType, $this->allowedObjectTypes)) {
            return $result;
        }
    
        // perform validation
        if (!$this->validateFileUpload($objectType, $file, $fieldName)) {
            return $result;
        }
    
        // build the file name
        $fileName = $file->getClientOriginalName();
        $fileNameParts = explode('.', $fileName);
        $extension = null !== $file->guessExtension() ? $file->guessExtension() : $file->guessClientExtension();
        if (null === $extension) {
            $extension = strtolower($fileNameParts[count($fileNameParts) - 1]);
        }
        $extension = str_replace('jpeg', 'jpg', $extension);
        $fileNameParts[count($fileNameParts) - 1] = $extension;
        $fileName = implode('.', $fileNameParts);
    
        $flashBag = $this->session->getFlashBag();
    
        // retrieve the final file name
        try {
            $basePath = $this->getFileBaseFolder($objectType, $fieldName);
        } catch (\Exception $exception) {
            $flashBag->add('error', $exception->getMessage());
            $this->logger->error('{app}: User {user} could not detect upload destination path for entity {entity} and field {field}. ' . $exception->getMessage(), ['app' => 'MUNewsModule', 'user' => $this->currentUserApi->get('uname'), 'entity' => $objectType, 'field' => $fieldName]);
    
            return $result;
        }
        $fileName = $this->determineFileName($objectType, $fieldName, $basePath, $fileName, $extension);
    
        $destinationFilePath = $basePath . $fileName;
        $targetFile = $file->move($basePath, $fileName);
    
        // validate image file
        $isImage = in_array($extension, $this->imageFileTypes);
        if ($isImage) {
            $imgInfo = getimagesize($destinationFilePath);
            if (!is_array($imgInfo) || !$imgInfo[0] || !$imgInfo[1]) {
                $flashBag->add('error', $this->__('Error! This file type seems not to be a valid image.'));
                $this->logger->error('{app}: User {user} tried to upload a file which is seems not to be a valid image.', ['app' => 'MUNewsModule', 'user' => $this->currentUserApi->get('uname')]);
        
                return false;
            }
        }
        
        // validate size
        // get file size of uploaded image
        $fileSize = filesize($destinationFilePath);

        // get setting - mod var
        $maxSize = $this->moduleVars['maxSize'];
        
        // if not empty, validate
        if ('' !== $maxSize) {
            if (false !== strpos($maxSize, 'k')) {
                $sizeType = 'kilo';
            } elseif (false !== strpos($maxSize, 'M')) {
                $sizeType = 'mega';
            } elseif (false === strpos($maxSize, 'k') && false === strpos($maxSize, 'M')) {
                $sizeType = 'byte';
            }

            if ('byte' === $sizeType && $fileSize > $maxSize) {
                $flashBag->add('error', $this->__('Error! This file is too big.'));
                $flashBag->add('status', $this->__('Try another image or make the file size smaller than ') . $setMaxSize . ' ' . 'byte');

                return false;
            }

            if ('kilo' === $sizeType) {
                $maxSize = str_replace('k', '', $maxSize);
                $setMaxSize = $maxSize;
                $maxSize *= 1024;
                if ($fileSize > $maxSize) {
                    $flashBag->add('error', $this->__('Error! This file is too big.'));
                    $flashBag->add('status', $this->__('Try another image or make the file size smaller than ') . $setMaxSize . ' ' . 'kilobyte!');

                    return false;
                }
            }

            if ('mega' === $sizeType) {
                $maxSize = str_replace('M', '', $maxSize);
                $setMaxSize = $maxSize;
                $maxSize = $maxSize * 1024 * 1024;
                if ($fileSize > $maxSize) {
                    $flashBag->add('error', $this->__('Error! This file is too big.'));
                    $flashBag->add('status', $this->__('Try another image or make the file size smaller than ') . $setMaxSize . ' ' . 'megabyte!');
                    return false;
                }
            }
        }

        // collect data to return
        $result['fileName'] = $fileName;
        $result['metaData'] = $this->readMetaDataForFile($fileName, $destinationFilePath);
    
        $isImage = in_array($extension, $this->imageFileTypes);
        if ($isImage) {
            // fix wrong orientation and shrink too large image if needed
            @ini_set('memory_limit', '1G');
            $imagine = new Imagine();
            $image = $imagine->open($destinationFilePath);
            $autorotateFilter = new Autorotate();
            $image = $autorotateFilter->apply($image);
            $image->save($destinationFilePath);
    
            // check if shrinking functionality is enabled
            $fieldSuffix = ucfirst($objectType) . ucfirst($fieldName);
            if (isset($this->moduleVars['enableShrinkingFor' . $fieldSuffix]) && true === (bool)$this->moduleVars['enableShrinkingFor' . $fieldSuffix]) {
                // check for maximum size
                $maxWidth = isset($this->moduleVars['shrinkWidth' . $fieldSuffix]) ? $this->moduleVars['shrinkWidth' . $fieldSuffix] : 800;
                $maxHeight = isset($this->moduleVars['shrinkHeight' . $fieldSuffix]) ? $this->moduleVars['shrinkHeight' . $fieldSuffix] : 600;
                $thumbMode = isset($this->moduleVars['thumbnailMode' . $fieldSuffix]) ? $this->moduleVars['thumbnailMode' . $fieldSuffix] : ImageInterface::THUMBNAIL_INSET;
    
                $imgInfo = getimagesize($destinationFilePath);
                if ($imgInfo[0] > $maxWidth || $imgInfo[1] > $maxHeight) {
                    // resize to allowed maximum size
                    $imagine = new Imagine();
                    $image = $imagine->open($destinationFilePath);
                    $thumb = $image->thumbnail(new Box($maxWidth, $maxHeight), $thumbMode);
                    $thumb->save($destinationFilePath);
                }
            }
    
            // update meta data excluding EXIF
            $newMetaData = $this->readMetaDataForFile($fileName, $destinationFilePath, false);
            $result['metaData'] = array_merge($result['metaData'], $newMetaData);
        }
    
        return $result;
    }
}
